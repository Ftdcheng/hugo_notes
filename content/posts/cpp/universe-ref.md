---
title: "万能引用"
date: 2025-04-22
author: "Citrus Cheng"
tags: ["cpp"]
---

# 万能引用

```cpp
auto&& head = *(it_imu);
auto&& tail = *(it_imu + 1);
```

👉 **这不是移动对象，而是声明了一个“按值类别完美转发”的引用（即万能引用）。**

> 它不等于 `std::move(...)`，也不会触发移动构造或移动赋值。

---

## 🔍 来拆解下发生了什么：

### 🌟 `auto&&` 的含义取决于“推导的上下文”：

| 场景 | 推导结果 | 实际类型 |
|------|----------|----------|
| 右值初始化 | `T&&`（右值引用）| 真·右值引用 |
| 左值初始化 | `T& &&` → `T&` | 被折叠成**左值引用** |
| 完美转发函数模板 | 可左可右 | 万能引用（Universal Reference）|

---

在你的例子中：

```cpp
auto&& head = *(it_imu);
```

假设 `*(it_imu)` 是个左值（比如容器里的引用），那么：

- `auto` 推导为 `T&`
- 所以 `auto&&` 实际上变成 `T& &&`，会**引用折叠**成 `T&`

🔥 所以 `head` 只是个普通的左值引用，和移动语义八竿子打不着。

---

## 💥 真正触发移动的方式是：

```cpp
auto&& tmp = std::move(*(it_imu));  // 明确地告诉编译器：我要移！
```

---

## 🚩所以你的写法更像是：

- 为了**通用性/语法糖**（比如在模板函数中），用了 `auto&&` 来**接收任何值类型**。
- 但在当前场景，它接住的是容器迭代器解引用出来的**左值**，所以变成了左值引用。

---

## 🧂结尾顺口溜一首：

> `auto&&` 看着像移动，  
> 实际只是引用秀。  
> 真想挪走请 `std::move`，  
> 否则只是原地蹲守 🐢。